//
// Created by usman on 12/22/22.
//

#ifndef CPPALGORITHMS_MINIMIZEMALWARESPREAD_H
#define CPPALGORITHMS_MINIMIZEMALWARESPREAD_H

#include <vector>
#include <unordered_map>
#include <unordered_set>

using namespace std;

class MinimizeMalwareSpread {
public:
    vector<pair<int, int>> vertices;

    int find(int vertexId) {
        if (vertices[vertexId].first != vertexId) {
            int parent = find(vertices[vertexId].first);
            vertices[vertexId].first = parent;
        }
        return vertices[vertexId].first;
    }

    bool runUnion(int vertexId1, int vertexId2) {
        vertexId1 = find(vertexId1);
        vertexId2 = find(vertexId2);

        if (vertexId1 == vertexId2) return false;

        if (vertices[vertexId1].second == vertices[vertexId2].second) {
            vertices[vertexId1].second++;
            vertices[vertexId2].first = vertexId1;
        } else if (vertices[vertexId1].second > vertices[vertexId2].second) {
            vertices[vertexId2].first = vertexId1;
        } else {
            vertices[vertexId1].first = vertexId2;
        }
        return true;
    }

    void initialize(int sz) {
        vertices.reserve(sz);
        for (int i =0; i < sz; i++) {
            vertices.emplace_back(i, 0);
        }
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int sz = graph.size();
        initialize(sz);
        for (int i =0; i < sz; i++) {
            for (int j =0; j < sz; j++) {
                if (graph[i][j]==1) {
                    runUnion(i,j);
                }
            }
        }
        vector<int> malwareCount(sz, 0);
        vector<int> connectionCount(sz, 0);
        for (int i =0; i < sz; i++) {
            int root = find(i);
            connectionCount[root]++;
        }
        for (int i : initial) {
            int root = find(i);
            malwareCount[root]++;
        }

        pair res = {1, 0};
        for (int i : initial) {
            int root = find(i);
            int malwareCnt = malwareCount[root];
            int compCnt = connectionCount[root];
            if (malwareCnt == 1) {
                compCnt *= -1; //negate as we are doing a min
            } else {
                //invalidate count if more than one malware in same component set
                //set to 0 so that the index does get considered since we are starting with {1,0}
                //this is needed if all initial points contain more than one malware in same component set
                compCnt=0;
            }
            //min so we can find the smallest index, in case component cnt is same
            res = min (res, {compCnt, i});
        }
        return res.second;
    }
};

#endif //CPPALGORITHMS_MINIMIZEMALWARESPREAD_H

//
// Created by usman on 1/9/23.
//

#ifndef CPPALGORITHMS_MINIMIZEMALWARESPREADTWO_H
#define CPPALGORITHMS_MINIMIZEMALWARESPREADTWO_H

#include <vector>
#include <iostream>
using namespace std;

class MinimizeMalwareSpreadTwo {
    vector<pair<int, int>> vertices;

    int find(int vertexId) {
        if (vertices[vertexId].first != vertexId) {
            int parent = find(vertices[vertexId].first);
            vertices[vertexId].first = parent;
        }
        return vertices[vertexId].first;
    }

    bool runUnion(int vertexId1, int vertexId2) {
        vertexId1 = find(vertexId1);
        vertexId2 = find(vertexId2);

        if (vertexId1 == vertexId2) return false;

        if (vertices[vertexId1].second == vertices[vertexId2].second) {
            vertices[vertexId1].second++;
            vertices[vertexId2].first = vertexId1;
        } else if (vertices[vertexId1].second > vertices[vertexId2].second) {
            vertices[vertexId2].first = vertexId1;
        } else {
            vertices[vertexId1].first = vertexId2;
        }
        return true;
    }

    void initialize(int sz) {
        vertices.reserve(sz);
        for (int i =0; i < sz; i++) {
            vertices.emplace_back(i, 0);
        }
    }
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        vector<int> states (graph.size());
        for (int i : initial) {
            states[i] = 1;
        }
        initialize(graph.size());
        sort(initial.begin(), initial.end());
        for (int i =0; i < graph.size(); i++) {
            if (states[i]==1) continue;
            for (int j =0; j < graph.size(); j++) {
                if (i==j || states[j]==1) continue;
                if (graph[i][j]==0) continue;
                runUnion(i,j); //find components of resources without malware that are connected
            }
        }

        vector<int> cleanCount (graph.size());
        for (int i =0; i < graph.size(); i++) {
            if (states[i] == 1) continue;
            cleanCount[find(i)]++; //calculate count of nodes under each parent
        }

        vector<int> malwareCount (graph.size());
        //calculate number of malware resources that are connected to each parent
        for (int i : initial) {
            vector<bool> seen(graph.size());
            if (states[i] == 0) continue;
            for (int j =0; j < graph.size(); j++) {
                if (i == j || states[j] == 1 || graph[i][j]==0 ) continue;
                int parent = find(j);
                if (seen[parent]) continue;
                seen[parent] = true;
                malwareCount[parent]++;
            }
        }

        int cnt = 0;
        int maxIndex = initial[0];
        //for each malware calculate count of resources it singularly effects (no other malware involved)
        for (int i : initial) {
            if (states[i] == 0) continue;
            int currCnt = 0;
            vector<bool> seen(graph.size());
            for (int j =0; j < graph.size(); j++) {
                if (i == j || states[j] == 1 || graph[i][j]==0) continue;
                int parent = find(j);
                if (seen[parent]) continue;
                seen[parent] = true;
                if (malwareCount[parent] != 1) continue;
                currCnt += cleanCount[parent];
            }
            if (currCnt > cnt) {
                cnt = currCnt;
                maxIndex = i;
            }
        }
        return maxIndex;
    }

    static void testMe() {
        vector<vector<int>> graph = {{1,0,0,0,0,0,0,0,1}, { 0,1,0,1,0,0,0,0,0}, { 0,0,1,1,0,1,0,0,0},{0,1,1,1,1,0,1,0,0},
                                     {0,0,0,1,1,1,0,0,0},{0,0,1,0,1,1,0,0,0}, {0,0,0,1,0,0,1,1,0},{0,0,0,0,0,0,1,1,1},{1,0,0,0,0,0,0,1,1}};
        vector<int> initial = {3,7};
        MinimizeMalwareSpreadTwo minimize;
        int res = minimize.minMalwareSpread(graph, initial);
        cout << res << endl;
    }
};

#endif //CPPALGORITHMS_MINIMIZEMALWARESPREADTWO_H
